(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{376:function(s,t,e){"use strict";e.r(t);var a=e(25),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"sass를-사용하는-이유"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sass를-사용하는-이유"}},[s._v("#")]),s._v(" Sass를 사용하는 이유")]),s._v(" "),e("p",[s._v("기존 CSS의 한계를 넘어서기 위한 새로운 형태의 CSS의 일종이다. "),e("code",[s._v("CSS 전처리자")]),s._v("로 불리기도 하는데, 이러한 종류의 프레임워크로는\n"),e("code",[s._v("Sass")]),s._v(", "),e("code",[s._v("Less")]),s._v(", "),e("code",[s._v("Stylus")]),s._v(" 등이 있습니다. 이런 전처리자들은 웹에서 직접 사용할 수 없고 컴파일을 거쳐야 합니다.")]),s._v(" "),e("blockquote",[e("p",[s._v("전처리자를 사용하는 것이 더 불편하지는 않을까?\n전처리자를 사용하기 위해서는 스타일시트를 어떤 구조로 분리할 것인지, 어떤 구문을 변수나 함수화할 것인지, 확장성 높은 모듈화에 관해 고민하게 만듭니다. 이런 작업은 CSS와 HTML의 논리성을 강화하며, 협업하는 사람들이 논리 체계를 파악하는 것만으로 작업물 전체의 구조를 파악할 수 있도록 도움을 줍니다.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);